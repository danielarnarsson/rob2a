#pragma config(Sensor, in1,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centreLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in4,    lightSensor,    sensorReflection)
#pragma config(Sensor, in5,    Potentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           leftMotor,     tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                            - Moving Forward -                                      *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs your robot to move forward for distance then backward then forward again   *|
|*  incrementing .5 m each time until 2.5 m                                                           *|
|*                                                                                                    *|
\*----------------------------------------------------------------------------------------------------*/




task main()

    wait1Mspec(2000);

    SensorValue[rightEncoder] = 0;
    SensorValue[leftEncoder] = 0;
    //First Forward Movement
    while(SensorValue[leftEncoder] < 1260)
    {
        if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
        {
            motor[rightMotor] = 63;
            motor[leftMotor] = 50;
        }
        if(SensorValue[rightEncoder] > SensorValue[leftEncoder])
        {
            motor[rightMotor] = 50;
            motor[leftMotor] = 63;
        }
        if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
        {
            motor[rightMotor] = 63;
            motor[leftMotor] = 63;
        }
    }

    SensorValue[rightEncoder] = 0;
    SensorValue[leftEncoder] = 0;
    //left Turn
    while(SensorValue[leftEncoder] < 720)
    {
        motor[rightMotor] = 63;
        motor[leftMotor] = -63;
    }

    SensorValue[rightEncoder] = 0;
    SensorValue[leftEncoder] = 0;
    //Second Forward Movement
    while(SensorValue[leftEncoder] < 1080)
    {
        if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
        {
            motor[rightMotor] = 63;
            motor[leftMotor] = 50;
        }
        if(SensorValue[rightEncoder] > SensorValue[leftEncoder])
        {
            motor[rightMotor] = 50;
            motor[leftMotor] = 63;
        }
        if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
        {
            motor[rightMotor] = 63;
            motor[leftMotor] = 63;
        }
    }

    SensorValue[rightEncoder] = 0;
    SensorValue[leftEncoder] = 0;
    //Right Turn
    while(SensorValue[leftEncoder] < 720)
    {
        motor[rightMotor] = -63;
        motor[leftMotor] = 63;
    }


    SensorValue[rightEncoder] = 0;
    SensorValue[leftEncoder] = 0;
    //Third Forward Movement
    while(SensorValue[leftEncoder] < 800)
    {
        if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
        {
            motor[rightMotor] = 63;
            motor[leftMotor] = 50;
        }
        if(SensorValue[rightEncoder] > SensorValue[leftEncoder])
        {
            motor[rightMotor] = 50;
            motor[leftMotor] = 63;
        }
        if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
        {
            motor[rightMotor] = 63;
            motor[leftMotor] = 63;
        }
    }

    SensorValue[rightEncoder] = 0;
    SensorValue[leftEncoder] = 0;
    //Right Turn
    while(SensorValue[leftEncoder] < 720)
    {
        motor[rightMotor] = -63;
        motor[leftMotor] = 63;
    }

    SensorValue[rightEncoder] = 0;
    SensorValue[leftEncoder] = 0;
    //Fourth Forward Movement
    while(SensorValue[leftEncoder] < 600)
    {
        if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
        {
            motor[rightMotor] = 63;
            motor[leftMotor] = 50;
        }
        if(SensorValue[rightEncoder] > SensorValue[leftEncoder])
        {
            motor[rightMotor] = 50;
            motor[leftMotor] = 63;
        }
        if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
        {
            motor[rightMotor] = 63;
            motor[leftMotor] = 63;
        }
    }
}
